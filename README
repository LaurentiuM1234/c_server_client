=====================================SERVER====================================
(*) informatii generale: - o comanda primita de la un client TCP poate avea
maxim 200 caractere.
                         - o comanda primita de la un client TCP trebuie sa
aibe argumentele separate prin spatii si nu poate sa aibe mai mult de 5 argumente

                         - in momentul in care un client TCP se aboneaza la un
topic el va ramane abonat la acel topic pana in momentul in care se dezaboneaza
(ramane abonat chiar daca se deconecteaza si apoi se reconecteaza)


                         - daca un client TCP incearca sa se aboneze la un topic
cu 2 valori diferite ale SF-ului atunci serverul o sa tina cont doar de prima
abonare (pentru a schimba SF-ul clientul trebuie sa se dezaboneze mai intai)

                         - logica serverului este impartita in urmatoarele
module: 1) connection - ofera o abstractizare a API-ului sys/socket pentru a-l
putea folosi in partea de prelucrare de date si conexiune cu clientii
        2) data - ofera functii pentru prelucrarea datelor de la nivelul
aplicatiei
        3) user - modul auxiliar ce ofera functii pentru modelarea clientilor
TCP la nivelul aplicatiei

                               - pentru ca este posibil ca apelurile de sistem
send si recv sa nu trimita exact numarul de octeti dati ca parametru am realizat
2 wrappere: tcp_send si tcp_recv care transmit si primesc octeti pana numarul de
octeti primit/trimis ajunge la cel asteptat
                               - serverul nu verifica daca portul are un format
invalid(daca @strtol nu seteaza errno sau nu intoarce o valoare negativa serverul
va considera ca portul este valid)

(**) protocol nivel aplicatie: - serverul pune mesajele de la clientii UDP
intr-un payload la care se adauga un "header" ce contine informatiile clientului
UDP ce a transmis mesajul (structura de tip @sockaddr_in) (toate aceste informatii
sunt tinute intr-o structura de tip messate)
                               - serverul va transmite clientilor TCP exact
sizeof(struct message) octeti
                               - in momentul in care un client se deconecteaza
acesta nu este sters din lista de clienti, ci marcat ca "inactiv"; daca un alt
client cu alta adresa IP se conecteaza cu acelasi ID ca un client "inactiv" el
va sterge entry-ul clientului "inactiv" din lista de clienti si il va adauga pe
al lui
                         - serverul se asteapta ca un client TCP sa trimita id-ul
imediat dupa ce se realizeaza conexiunea

                         - serverul se asteapta ca mesajul primit de la client
ce contine ID-ul sau sa aiba exact 11 octeti

                                - daca un client este "inactiv" si primeste mesaje
cu topicuri la care este abonat si are SF activat, serverul le va stoca in lista
de mesaje netrimise si i le va trimite acestuia in momentul in care se reconecteaza
===============================================================================


===============================CLIENT==========================================
(*) informatii generale: - clientul nu verifica daca id-ul are mai mult de 11
caractere, daca adresa ip a serverului are un format valid sau daca portul este
invalid (atata timp cat apelurile de sistem nu returneaza vreo eroare clientul
va considera ca toate sunt valide)
                         - comanda data de user nu poate depasi 200 de caractere
si nu poate avea mai mult de 5 argumente(separate prin spatiu)

(**) protocol nivel aplicatie: - clientul va transmite exact 11 octeti ce contin
id-ul acestuia dupa realizarea conexiunii cu serverul
                               - clientul se asteapta sa primeasca de la server
exact sizeof(struct message) octeti in momentul in care acesta vrea sa-i transmita
un mesaj de la un client UDP
                               - pentru interpretarea datelor primite de la server,
clientul va adauga un octet(terminatorul de sir) la bufferele pentru content si topic
pentru a le putea afisa
===============================================================================

========================INFORMATII GENERALE APLICATIE==========================
- am setat valoarea backlog-ului(in functia @listen) la 10, dar aplicatia ar 
trebui sa mearga ok si pentru alte valori

(*) de ce goto-uri?
 - fac codul mai usor de urmarit atunci cand este vorba de error handling
 - prin folosirea lor se evita aparitia de mai multe ori a aceleiasi bucati
de cod pentru eliberarea unor resurse

- am folosit goto-uri doar in functiile in care trebuia eliberata aceeasi resursa
in mai multe parti in caz de eroare

(**) error handling
 - erorile se propaga pana in main unde se afiseaza mesajele corespunzatoare
la stderr folosind @print_error (exceptie fac erorile care au trebuit tratate mai devreme
de main; de regula ele au un comentariu care spune ca au fost "silenced")

- sursele pentru server se gasesc in @serv, cele pentru client in @cli, iar cele
comune in radacina arhivei (sursele serverului si cele al clientului nu ar trebui
scoase din fisierele cli si serv deoarece unele au aceeasi denumire) 
==============================================================================
